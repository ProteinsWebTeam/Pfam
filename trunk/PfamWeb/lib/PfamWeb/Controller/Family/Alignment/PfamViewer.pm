
# PfamViewer.pm
# jt6 20060601 WTSI
#
# $Id: PfamViewer.pm,v 1.1 2007-07-26 14:58:54 jt6 Exp $

=head1 NAME

PfamWeb::Controller::Family::Alignment::PfamViewer - viewing sequence alignments

=cut

package PfamWeb::Controller::Family::Alignment::PfamViewer;

=head1 DESCRIPTION

Various methods for viewing alignments.

$Id: PfamViewer.pm,v 1.1 2007-07-26 14:58:54 jt6 Exp $

=cut

use strict;
use warnings;

use Data::Pageset;
use Bio::Pfam::ColourAlign;

use base 'PfamWeb::Controller::Family::Alignment';

#-------------------------------------------------------------------------------

=head1 METHODS

=head2 auto : Private

Overrides "auto" from the parent class to avoid checking parameters twice.

=cut

sub auto : Private {
  return 1;
}

#-------------------------------------------------------------------------------

=head2 showPfamViewer : Path

This is the way into the Pfam sequence alignment viewer.

Hands straight off to a template that generates a "tool" page containing the 
necessary hooks to load the interactive alignment viewer.

=cut

sub showPfamViewer : Path {
  my( $this, $c ) = @_;

  $c->stash->{template} = 'components/blocks/family/alignmentTool.tt';
}

#-------------------------------------------------------------------------------

=head2 view : Local

Generates a segment of a sequence alignment. Retrieves the alignment
from DAS sources and determines start/end row numbers from parameters.

This action shouldn't really be called directly, but via the page
generated by C<showAlignment>.

=cut

sub view : Local {
  my( $this, $c ) = @_;

  return unless defined $c->stash->{pfam};

  # somewhere to dump the paging info
  $c->stash->{alignments} = {};

  #----------------------------------------

  # use a different DAS source for seed vs full
  my( $numRowsInAlignment, $dsn );
  if( $c->stash->{alnType} eq 'seed' ) {
    $dsn = 'http://das.sanger.ac.uk/das/pfamSeedAlign';
    $numRowsInAlignment = $c->stash->{pfam}->num_seed;
  } else {
    $dsn = 'http://das.sanger.ac.uk/das/pfamFullAlign';
    $numRowsInAlignment = $c->stash->{pfam}->num_full;
  }
  $c->log->debug( "Alignment::PfamViewer::view: |$numRowsInAlignment| rows in alignment" );

  #----------------------------------------

  # get the scroll position
  if( defined $c->req->param('scrollValue') and
      $c->req->param('scrollValue') =~ m/^(\d+\.\d+)$/ ) {
    $c->stash->{scrollValue} = $1;
  } else {
    $c->stash->{scrollValue} = 0;
  }
  $c->log->debug( "Alignment::PfamViewer::view: set scroll value to |"
                  . $c->stash->{scrollValue} . "|" );

  #----------------------------------------

  # get the number of alignment lines to display
  my( $numRowsToShow ) =
    $c->req->param('numRows') || $this->{defaultRows} =~ m/^(\d+)$/;
  $numRowsToShow = $numRowsInAlignment if $numRowsInAlignment < $numRowsToShow;

  $c->log->debug( "Alignment::PfamViewer::view: showing |$numRowsToShow| rows" );

  #----------------------------------------

  # use a Data::Pageset object to keep track of all this...
  my $pager = Data::Pageset->new( { total_entries    => $numRowsInAlignment, 
                                    entries_per_page => $numRowsToShow,
                                    pages_per_set    => 11,
                                    mode             => 'slide' } );
  $c->stash->{pager} = $pager;

  # find out what page we want for this request
  my $page;
  if( defined $c->req->param('page') ) {
    ( $page ) = $c->req->param('page') =~ m/^(\d+)$/;
    $c->log->debug( "Alignment::PfamViewer::view: requested page number |$page|" );
  } elsif( defined $c->req->param('next') ) {
    $page = $pager->next;
    $c->log->debug( 'Alignment::PfamViewer::view: requested next page' );
  } elsif( defined $c->req->param('prev') ) {
    $page = $pager->prev;
    $c->log->debug( 'Alignment::PfamViewer::view: requested previous page' );
  }
  $page ||= 1;
  $c->log->debug( "Alignment::PfamViewer::view: showing page |$page|" );
  
  $pager->current_page( $page ); 

  #----------------------------------------

  # decide which actual rows we need to use now
  my $rows = $pager->first . '-' . $pager->last;
  $c->log->debug( "Alignment::PfamViewer::view: rows: |$rows|" );

  # store the lists of page numbers before and after the current one, for use
  # by the template in generating the list of available pages
  $c->stash->{pagesBefore} = [         1 .. $page - 1         ] if $page > 1;
  $c->stash->{pagesAfter}  = [ $page + 1 .. $pager->last_page ] if $page < $pager->last_page;
  
  #----------------------------------------

  # retrieve the DasLite client from the base model class and hand it
  # the DSN
  my $dl = $c->model('PfamDB')->getDasLite;
  $dl->dsn( $dsn );

  # retrieve the raw alignment fragment and associated features via DAS and 
  # generate the consensus sequence 
  my $rawAlignment = $dl->alignment( { query => $c->stash->{acc},
                                       rows  => $rows } );
  my $features     = $dl->features( $c->stash->{acc} );
  my $consensus    = Bio::Pfam::ColourAlign::parseConsensus( getConsensus( $features ) );
#  $c->log->debug( "rawAlignment: " . dump $rawAlignment );
#  $c->log->debug( "features:     " . dump $features );

  # build the marked-up alignment
  my( $alignments, $alignmentLengths ) = reconstructAli( $rawAlignment );
  my @markedUpAlignments;
  foreach my $alignment ( @$alignments ) {
    push @markedUpAlignments, 
      Bio::Pfam::ColourAlign::markupAlignSeparate( $alignment, $consensus );
  }

  #----------------------------------------

  # stash the stuff that we built and set the template
  $c->stash->{alignments}->{alignments} = \@markedUpAlignments;
  $c->stash->{alignments}->{lengths}    = $alignmentLengths;
  $c->stash->{template} = 'components/blocks/family/alignmentFragment.tt';
}

#-------------------------------------------------------------------------------
#- private methods -------------------------------------------------------------
#-------------------------------------------------------------------------------

# reconstructs a blocked alignment from a raw alignment

sub reconstructAli {
  my $ali = shift;
  my ($source, $aliData) = each %$ali;

  my( @alignments, @alignmentLengths );

  for( my $i = 0; $i < scalar(@$aliData); $i++ ) {
    my %aliObjects = 
      map{ $_->{alignobject_intObjectId} => $_ } @{ $aliData->[$i]->{alignobject} };
  
    push @alignmentLengths, $aliData->[$i]->{alignment_max};
  
    foreach my $block ( sort { $a->{block_blockOrder} <=> $b->{block_blockOrder} }
                             @{$aliData->[$i]->{block} } ) {
      my %ali;
      foreach my $bseqRef (@{ $block->{segment} } ) {
  
        my $key = $bseqRef->{segment_intObjectId} . '/' . 
                  $bseqRef->{segment_start}       . '-' . 
                  $bseqRef->{segment_end};
    
        $ali{$key} = &getAliString($bseqRef, \%aliObjects);
      }
      push @alignments, \%ali;
    }
  }
  return \@alignments, \@alignmentLengths;
}

#-------------------------------------------------------------------------------
# get the alignment string from the alignment

sub getAliString{
  my( $bseqRef, $aliObjectsRef ) = @_;

  my $seqStr = $aliObjectsRef->{ $bseqRef->{segment_intObjectId} }->{sequence};

  my $seq = substr( $seqStr,
                    $bseqRef->{segment_start} - 1,
                    $bseqRef->{segment_end} - $bseqRef->{segment_start} + 1 );

  my $aliString = cigar2align( $bseqRef->{cigar}, $seq );

  return $aliString;
}

#-------------------------------------------------------------------------------
# convert a cigar string into an alignment row

sub cigar2align  {
  my $cigar = shift;

  $cigar =~ s/\"//g;

  my $seq = shift;
  my $tmp = $cigar;
  my $start = 0;
  my $len = length($seq);

  $tmp =~ s/(\d+)D/'-'x$1/eg;
  $tmp =~ s/D/\-/g;
  $tmp =~ s/(\d+)I/'.'x$1/eg;
  $tmp =~ s/I/\./g;

  $tmp =~ s/(\d{0,5})M/if($1){$start+=$1,($start<=$len)?substr($seq,$start-$1,$1):'~'x$1}else{$start+=1,($start<=$len)?substr($seq,$start-1,1):'~'}/eg;

  return $tmp;
}

#-------------------------------------------------------------------------------
# calculate the consensus sequence

sub getConsensus {
  my $con = shift;

  my( $source, $featuresRef ) = each %$con;
  return $featuresRef->[0]->{feature_label};
}

#-------------------------------------------------------------------------------

=head1 AUTHOR

John Tate, C<jt6@sanger.ac.uk>

Rob Finn, C<rdf@sanger.ac.uk>

=head1 COPYRIGHT

Copyright (c) 2007: Genome Research Ltd.

Authors: Rob Finn (rdf@sanger.ac.uk), John Tate (jt6@sanger.ac.uk)

This is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
or see the on-line version at http://www.gnu.org/copyleft/gpl.txt

=cut

1;
