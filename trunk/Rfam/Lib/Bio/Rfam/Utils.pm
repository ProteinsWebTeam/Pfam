package Bio::Rfam::Utils;

#TODO: add pod documentation to all these functions

#Occasionally useful Rfam utilities

use strict;
use warnings;
use Sys::Hostname;
use File::stat;

#use Rfam::RfamSearch;
use Cwd;
use Data::Dumper;
use Mail::Mailer;
use File::Copy;
use vars qw( @ISA
             @EXPORT
);

@ISA    = qw( Exporter );

#Returns true if the CM file has been calibrated:
sub isCmCalibrated {
    my $cm = shift; #Handed a CM file generated by cmbuild and hopefully cmcalibrate'd
    $cm = 'CM' if not defined $cm;
    return 0 if not -s $cm;

    open(CM, "< $cm") or die "FATAL: failed to open the file $cm for a calibration check\n[$!]";
    my $ok=0;
    while(<CM>){
	if (/^ECMLC/){
	#if (/^CCOM.+cmcalibrate/){
	   $ok=1;
	   last;
	}
    }
    return $ok;
}

sub wait_for_farm {
    
    my ($bjobname, $jobtype, $nobjobs, $toKill, $debug) = @_;
    
    my $wait = 1;
    my $bjobcount = 1;
    my $bjobinterval = 15;
    my $jobs = $nobjobs;
    my $startTime = time();
    my $nowTime=0;
    my $firstRun;
    while($wait){
	
	sleep($bjobinterval); 
	
	$jobs = 0;
	my ($bjpend, $bjrun)  = (0, 0);
	open(S, "bjobs -J $bjobname |") or die "FATAL: failed to open pipe \'bjobs -J $bjobname |\'\n[$!]";
	while(<S>) {
	    $bjpend++ if (/PEND/);
	    $bjrun++ if (/RUN/);
	    if (/RUN/ && not defined $firstRun){
		$firstRun = time();
	    }
	}
	close(S);
	$jobs = $bjpend + $bjrun;
	
	$jobs = $nobjobs if $jobtype eq 'cmcalibrate' && $bjrun == 1;
	
	if ($jobs < int($nobjobs*(1-0.95)) ){#Once 95% of jobs are finished, check frequently.
	    $bjobinterval=15;
	}      
	elsif ($jobs < int($nobjobs*(1-0.90)) ){#Once 90% of jobs are finished, check a little more frequently.
	    $bjobinterval=15 + int(log($bjobcount/2)); 
	}
	else {#otherwise check less & less frequently (max. interval is ~300 secs = 5 mins).
	    if ($bjobinterval<300){ $bjobinterval = $bjobinterval + int(log($bjobcount));}
	}
	
	if($jobs){
	    $nowTime = time();
	    my @humanTime = gmtime($nowTime-$startTime);
	    printf STDERR "There are $jobs $jobtype jobs of $nobjobs still running after $bjobcount checks (PEND:$bjpend,RUN:$bjrun). Check interval:$bjobinterval secs [TotalTime=%dD:%dH:%dM:%dS].\n", @humanTime[7,2,1,0]; 
	    if(defined $toKill && defined $firstRun && ($nowTime-$firstRun)>$toKill){
		printf STDERR "WARNING: this job is taking too long therefore I am backing out. Hopefully it'll restart nicely.\n";
		#########
		#DEBUG -- MOSTLY TO TRACK DOWN MPI PROBLEMS:
		#MAKES A FILE FOR EACH MPIRUN NODE CONTAINING STRACE INFO AND PS.
		if (defined $debug){
		    printf STDERR "DEBUG start!\n";
		    
		    my $user =  'pg5';
		    $user =  getlogin() if defined getlogin();
		    my $pwd = getcwd;
		    print "DEBUG: pwd=$pwd, user=$user\n";
		    open(S, "bjobs -J $bjobname |") or die "FATAL: failed to open pipe \'bjobs -J $bjobname |\'\n[$!]";
		    while(<S>) {
			if(/(\d+)\*(bc-\S+)/){
			    my $node = $2;
			    print "node: $node\n";
			    open(B, "ssh $node ps -U $user -o pid,user,\%cpu,\%mem,cmd --sort cmd |") or warn "FATAL: failed to open pipe [ssh $node ps -U $user -o pid,user,\%cpu,\%mem,cmd --sort cmd]\n[$!]";
			    while(my $b=<B>) {
				print $b;
				if($b=~/(\d+)\s+\S+\s+(\S+)\s+(\S+).+$debug/){
				    # 6456 pg5      99.7  0.1 /software/rfam/share/infernal-1.0/bin/cmcalibrate --mpi -s 1 CM
				    my $debugFile="\$HOME/$$\.mpi.debug.$debug.$1.$node";
				    print("ssh $node \'strace -p $1 -o $debugFile\'");
				}
			    }	    
			    close(B);
			}
		    }
		    close(S);
		}
		printf STDERR "DEBUG end!\n";
		#DEBUG ENDS
		########
		system("bkill -J $bjobname ") and die "FATAL: failed to run [bkill -J $bjobname]\n[$!]";
	    }
	}else{
	    $wait = 0;
	}
	$bjobcount++;
    }
    
    return 1;
    
}

####################

sub eslSfetch_Cf {
    my ($sfetch, $dbfile, $infile, $outfile) = @_;

    my $command = "$sfetch -Cf $dbfile $infile > $outfile";
    system("$command");
    if($?) { die "FAILED: $command"; }
    return;
}
# FROM RfamUtils.pm:

######################################################################
#reorder: given 2 integers, return the smallest first & the largest last:
sub reorder {
    my ($x,$y)=@_;
    
    if ($y<$x){
	my $tmp = $x;
	$x = $y;
	$y = $tmp;
    }
    return ($x,$y);
}

#max
sub max {
  return $_[0] if @_ == 1;
  $_[0] > $_[1] ? $_[0] : $_[1]
}

#min
sub min {
  return $_[0] if @_ == 1;
  $_[0] < $_[1] ? $_[0] : $_[1]
}


######################################################################
# Returns the extent of overlap between two regions A=($x1, $y1) and B=($x2, $y2):
# - assumes that $x1 < $y1 and $x2 < $y2.
#
sub overlapExtent {
    my($x1, $y1, $x2, $y2) = @_;
    
    if($x1 > $y1) { die "ERROR overlapExtent, expect x1 <= y1 but $x1 > $y1"; }
    if($x2 > $y2) { die "ERROR overlapExtent, expect x2 <= y2 but $x2 > $y2"; }

    my $L1=$y1-$x1+1;
    my $L2=$y2-$x2+1;
    my $minL = Bio::Rfam::TempRfam::min($L1, $L2);
    
    my $D = overlapNres($x1, $y1, $x2, $y2);
    return $D/$minL;
}

######################################################################
# Returns the number of residues of overlap between two regions A=($x1, $y1) and B=($x2, $y2):
# - assumes that $x1 < $y1 and $x2 < $y2.
#
sub overlapNres {

    my($x1, $y1, $x2, $y2) = @_;
    
    if($x1 > $y1) { die "ERROR overlapNres, expect x1 <= y1 but $x1 > $y1"; }
    if($x2 > $y2) { die "ERROR overlapNres, expect x2 <= y2 but $x2 > $y2"; }

    # 1.
    # x1                   y1
    # |<---------A--------->|
    #    |<------B------>|
    #    x2             y2
    #    XXXXXXXXXXXXXXXXX
    #
    # 2.  x1                     y1
    #     |<---------A----------->|
    # |<-------------B------>|
    # x2                    y2
    #     XXXXXXXXXXXXXXXXXXXX
    #
    # 3. x1             y1
    #    |<------A------>|
    # |<---------B--------->|
    # x2                   y2
    #    XXXXXXXXXXXXXXXXX
    #
    # 4. x1                    y1
    #    |<-------------A------>|
    #        |<---------B----------->|
    #        x2                     y2
    #        XXXXXXXXXXXXXXXXXXXX
    my $D=0;
    my $int=0;
    my $L1=$y1-$x1+1;
    my $L2=$y2-$x2+1;
    my $minL = Bio::Rfam::TempRfam::min($L1, $L2);

    if ( ($x1<=$x2 && $x2<=$y1) && ($x1<=$y2 && $y2<=$y1) ){    #1.
	$D = $L2;
    }
    elsif ( ($x2<=$x1) && ($x1<=$y2 && $y2<=$y1) ){              #2.
	$D = $y2-$x1+1;
    }
    elsif ( ($x2<=$x1 && $x1<=$y2) && ($x2<=$y1 && $y1<=$y2) ){ #3.
	$D = $L1;
    }
    elsif ( ($x1<=$x2 && $x2<=$y1) && ($y1<=$y2) ){              #4.
	$D = $y1-$x2+1;
    }
    return $D;
}

=head2 cm_evalue2bitsc()

  Title    : cm_evalue2bitsc()
  Incept   : EPN, Tue Jan 29 17:18:43 2013
  Usage    : cm_evalue2bitsc($cm, $evalue)
  Function : Returns bit score for a given E-value
  Args     : <cm>:     Bio::Rfam::Family::CM object
           : <evalue>: E-value we want bit score for
           : <Z>:      database size (both strands) for E-value->bitsc calculation
  Returns  : bit score for E-value for CM in db of $Z residues 
           : (where $Z includes BOTH strands of target seqs)
  
=cut

sub cm_evalue2bitsc { 
    my ($cm, $evalue, $Z) = @_;
    
    # following from infernal's cmstat.c line 295 ('else if(output_mode == OUTMODE_BITSCORES_E) {')
    my $eline; # E-value stat line from CM file
    my ($lambda, $mu_extrap, $mu_orig, $dbsize, $nhits, $tailp); # E-value stat components from CM file
    my $cur_eff_dbsize; # current effective dbsize
    my $bitsc; # bit score to return;

    # variables only used if HMM stats apply
    my $tau; # used if HMM stats are used
    my $maxlen; # maximum lenght

    # TODO, only use HMM stat line if --nohmmonly was NOT used in SM
    if($cm->{match_pair_node}) { # use CM stats
	# TODO, read SM in desc, and pick appropriate E-value line based on that
	$eline = $cm->{cmHeader}->{ecmli};
	($lambda, $mu_extrap, $mu_orig, $dbsize, $nhits, $tailp) = split(/s+/, $eline);
	$cur_eff_dbsize = ($Z / $dbsize) * $nhits;
	$bitsc = $mu_extrap + ((log($evalue / $cur_eff_dbsize)) / (-1 * $lambda));
    }
    else { 
	$eline = $cm->{cmHeader}->{efp7gf};
	($tau, $lambda) = split(/\s+/, $eline);
	$maxlen = $cm->{cmHeader}->{maxl};
	$bitsc = $tau + ((log($evalue / ($Z / $maxlen))) / (-1 * $lambda));
    }
    
    printf("in cm_evalue2bitsc() converted E-value $evalue to bit $bitsc (Z: $Z)\nEline: $eline\n");
    return $bitsc;
}

######################################################################
#species2shortspecies: Given a species string eg. "Homo sapiens
#                      (human)" generate a nicely formated short name
#                      with no whitespace eg. "H.sapiens".
sub species2shortspecies {
    my $species = shift;
    my $shortSpecies;
    
    if ($species=~/(.*)\s+sp\./){
	$shortSpecies = $1;
    }
    elsif ($species=~/metagenome/i or $species=~/uncultured/i){
	$species=~s/metagenome/metag\./gi;
	$species=~s/uncultured/uncult\./gi;
	my @w = split(/\s+/,$species);
	if(scalar(@w)>2){
	    foreach my $w (@w){
		$shortSpecies .= substr($w, 0, 5) . '.';
	    }
	}
	else {
	    $shortSpecies = $species;
	    $shortSpecies =~ s/\s+/_/g;
	}
    }#lots of conditions here. Need else you get some ridiculous species names.
    elsif($species=~/^(\S+)\s+(\S{4,})/ && $species!~/[\/\-\_0-9]/ && $species!~/^[a-z]/ && $species!~/\svirus$/ && $species!~/\svirus\s/ && $species!~/^Plasmid\s/i && $species!~/\splasmid\s/i){
	$shortSpecies = substr($1,0,1) . "." . $2; 
    }
    else {
	$shortSpecies = $species;
    }
    
    $shortSpecies =~ s/\s+/_/g;
    $shortSpecies =~ s/[\'\(\)\:\/]//g;
    $shortSpecies = substr($shortSpecies,0,20) if (length($shortSpecies) > 20);
    
#   H.P 
    return $shortSpecies;
}

=head2 nse2len()

  Title    : nse2len()
  Incept   : EPN, Wed Jan 30 13:23:31 2013
  Usage    : nse2len($sqname)
  Function : Returns length of a sequence given a sqname in N/S-E format
  Args     : $sqname in N/S-E format
  Returns  : length in residues of sequence
  
=cut
sub nse2len {
    my($sqname) = @_;
    my($n, $s, $e);
    
    if($sqname =~ m/^(\S+)\/(\d+)\-(\d+)\s*/) {
	($n, $s, $e) = ($1,$2,$3);
	if($s <= $e) { return ($e-$s+1); }
	else         { return ($s-$e+1); }
    }
    die "ERROR: nse2len() $sqname doesn't match expected format of N/S-E";
}

=head2 stringize_infernal_cmdline_options()

  Title    : stringize_infernal_cmdline_options()
  Incept   : EPN, Thu Jan 31 16:52:35 2013
  Usage    : stringize_infernal_cmdline_options($sdashAR, $ddashAR)
  Function : Returns option string including single dash and double dash
           : options in $sdashAR and $ddashAR.
  Args     : Array ref to array of single dash options
           : Array ref to array of double dash options
  Returns  : string of options
  
=cut
sub stringize_infernal_cmdline_options {
    my ($sdashAR, $ddashAR) = @_;

    my $optstring = "";
    my $opt;

    foreach $opt (@{$sdashAR}) { $optstring .= "\-$opt ";  }
    foreach $opt (@{$ddashAR}) { $optstring .= "\--$opt "; }
    
    $optstring =~ s/\s+$//;

    return $optstring;
}

######################################################################

=head1 AUTHOR

Sarah Burge, swb@ebi.ac.uk

=head1 COPYRIGHT

Copyright (c) 2013: European Bioinformatics Institute

Authors: Sarah Burge swb@ebi.ac.uk

This is based on code taken from the Rfam modules at the Sanger institute.

This is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
details.

You should have received a copy of the GNU General Public License along with
this program. If not, see <http://www.gnu.org/licenses/>.

=cut

1;



