#!/usr/local/bin/perl -w

BEGIN {
    $rfam_mod_dir = 
        (defined $ENV{'RFAM_MODULES_DIR'})
            ?$ENV{'RFAM_MODULES_DIR'}:"/pfam/db/Rfam/scripts/Modules";
    $bioperl_dir =
        (defined $ENV{'BIOPERL_DIR'})
            ?$ENV{'BIOPERL_DIR'}:"/pfam/db/bioperl";
}

use lib $rfam_mod_dir;
use lib $bioperl_dir;

use Getopt::Long;

use strict;
use IO::File;
use Rfam::RfamAlign;

sub usage {
    print STDERR <<EOF;
Usage: $0 <alignfile>

optional args:
   -split        : split into subfamilies (takes significantly longer)
   -robust <n>   : allow errors in alignment (default 0.01 - 0.05 might be better for poorer alignments)
EOF
}

my $robust = 0.01; # Range between 0 and 1
my $split;
&GetOptions( 'robust=s'  => \$robust,
	     'split'     => \$split );

my $file = shift;
if( not $file ) {
    &usage();
    exit(1);
}

my $pfold_bindir  = '/pfam/db/Rfam/software/pfold/bin';
my $pfold_bindir2 = '/pfam/db/Rfam/software/pfold_join';
my $queue = 'pfam_fast';

my @alnfiles;
if( $split ) {
    open( A, $file ) or die;
    my $aln = new Rfam::RfamAlign;
    $aln -> read_stockholm( \*A );
    open( O, ">$$.fa" ) or die;
    $aln -> write_fasta( \*O );
    close O;
    my $fh = new IO::File;
    $fh -> open("| bsub -I -q $queue -Rlinux -o pfold_split.err") or die "$!";
    $fh -> print("$pfold_bindir2/cluster.tcsh $$.fa");
    $fh -> close();
    
    # ok - we rely on eachSeq returning seqs in the order they were read!
    my @seqs = $aln -> each_seq();
    my $j = 1;
    open( BEST, "$$"."_groups_best.txt" ) or die "can't open $$"."_groups_best.txt";
    while(<BEST>) {
	if( my ($line) = /^(\S+ )/ ) {
	    my $new = Rfam::RfamAlign -> new();
	    foreach my $i ( $line =~ /(\d+)[\,\s]/g ) {
		$new -> add_seq( $seqs[$i-1] );
	    }
	    open( O, ">$file.gp$j" ) or die;
	    $new -> write_stockholm( \*O );
	    close O;
	    push( @alnfiles, "$file.gp$j" );
	    $j++;
	}
    }
    close BEST;
}
else {
    push( @alnfiles, $file );
}

foreach my $alnfile ( @alnfiles ) {
    open( O, ">$alnfile.$$.col" ) or die;
    print O "; generated by fasta2col\n";
    print O "; ============================================================\n";

    open( A, $alnfile ) or die;
    my $aln = new Rfam::RfamAlign;
    $aln -> read_stockholm( \*A );
    foreach my $seq ( $aln -> each_seq() ) {
	print O "; TYPE              RNA\n";
	print O "; COL 1             label\n";
	print O "; COL 2             residue\n";
	print O "; COL 3             seqpos\n";
	print O "; COL 4             alignpos\n";
	print O "; ENTRY             ", $seq->id, "/", $seq->start, "-", $seq->end, "\n";
	print O "; ----------\n";
	my( $i, $j );
	
	foreach ( split( //, $seq->seq ) ) {
	    if( /[\.\-]/ ) {
		printf O ("G  %s      .  %5d\n", $_, ++$i);
	    }
	    else {
		printf O ("N  %s  %5d  %5d\n", $_, ++$j, ++$i);
	    }
	}
	print O "; **********\n";
    }
    close A;
    close O;

    my $fh = new IO::File;
    $fh -> open("| bsub -I -q $queue -Rlinux -f \"$alnfile.$$.col > /tmp/$alnfile.$$.col\" -f \"$alnfile.$$.out.fa < /tmp/$alnfile.$$.out.fa\" > /dev/null") or die "$!";
    $fh -> print("$pfold_bindir/findphyl $pfold_bindir/scfg.rate /tmp/$alnfile.$$.col > /tmp/$alnfile.$$.nj.col\n");
    $fh -> print("$pfold_bindir/mltree $pfold_bindir/scfg.rate /tmp/$alnfile.$$.nj.col > /tmp/$alnfile.$$.ml.col\n");
    $fh -> print("$pfold_bindir/scfg --robust=$robust --treeinfile $pfold_bindir/article.grm /tmp/$alnfile.$$.ml.col > /tmp/$alnfile.$$.res.col\n");
    $fh -> print("$pfold_bindir/addparen /tmp/$alnfile.$$.res.col | $pfold_bindir/col2fasta > /tmp/$alnfile.$$.out.fa\n");
    $fh -> close;

    open( O, ">$alnfile.$$.out.fa2" ) or die;
  WAIT: {
      open( S, "$alnfile.$$.out.fa" ) or do {
	  sleep 5;
	  redo WAIT;
      };
  }
    my $str;
    my %seq;
    my $nse;
    my $ready;
    while(<S>) {
	chomp;
	if( /^\>(\S+)/ ) {
	    $nse = $1;
	    $str = undef;
	    if( exists $seq{$nse} ) {
		$ready = 1;
	    }
	    else {
		$ready = 0;
	    }
	}
	elsif( $ready ) {
	    $str .= $_;
	}
	else {
	    $seq{ $nse } .= $_;
	}
    }
    close S;
    foreach my $nse ( keys %seq ) {
	print O ">$nse\n$seq{$nse}\n";
    }
    $str =~ tr/\(\)/\<\>/;
    print O ">#=GC_SS_cons\n$str\n";
    close O;

    if( $split ) {
	system "sreformat -u -r --gapsym '.' --mingap stockholm $alnfile.$$.out.fa2 | sed 's/GC_SS_cons/GC SS_cons/g' > $alnfile" and die;
    }
    else {
	system "sreformat -u -r --gapsym '.' --mingap stockholm $alnfile.$$.out.fa2 | sed 's/GC_SS_cons/GC SS_cons/g'" and die;
    }
}
