#!/usr/local/bin/perl -wT
#########
# Author: rmp
# Maintainer: rmp
# Created: 2002-06-08
# Last Modified: 2003-05-08
# retrieve blast results and do that parsing thang
#
use strict;
use CGI qw/:cgi/;
use lib "/nfs/WWW/SANGER_docs/perl/ensembl/ensembl/modules";
use lib "/nfs/WWW/SANGER_docs/perl/ensembl/ensembl-draw/modules";
use lib "/nfs/WWW/SANGER_docs/perl/bioperl-live";
use lib "/nfs/WWW/SANGER_docs/perl";
use lib "/nfs/WWW/SANGER_docs/bin-offline/Website/Blast";
use lib "/nfs/WWW/SANGER_docs/bin-offline";
use Website::Blast::Parser::Generic;
use Website::Blast::Util;
use Sanger::Graphics::JSTools;
use SangerWeb;

use lib "/nfs/WWW/SANGER_docs/cgi-bin/Rfam";
use lib '/nfs/WWW/SANGER_docs/perl/bioperl-1.2/';
use RfamWWWConfig;

$| = 1;
$ENV{'PATH'} = "";
&main();
1;

sub main {
  my $cgi    = CGI->new();
  my $util   = Website::Blast::Util->new();
  my $format = $cgi->param('format') || "default";
  my ($id)   = $cgi->param('id') =~ /([a-zA-Z0-9]+)/;
  $id      ||= "";
  my $sw;
  if($format eq "plain") {
    print "Content-type: text/plain\n\n";
  } else {
    $sw = SangerWeb->new({
			     'title'  => "Blast Server Results",
			     'banner' => "Blast Server Results",
			     'jsfile' => "/js/zmenu.js",
			    });
    my $util   = Website::Blast::Util->new();  
    my $shpath      = $util->hashpath($id);
    
#    open(_FILE, "$shpath" .".pfam");
#    my $pfam_format;
#    while(<_FILE>) {
#      if ($_ =~ /^format~(\S+)/) {
#	$pfam_format = $1;
#      }

#    }
#    close(_FILE);

    print "Content-type: text/html\n\n";
    my $head_info= "Sequence search results";
    #$head_info = "DNA Blast Server Results" if ($pfam_format =~ /halfwise/i);
   print &RfamWWWConfig::header($head_info);

  #  print "ID: $id , FORMAT: $format <BR>";
   # print $sw->header();
    print &js_menu_div();
    &retrieval_form($cgi, $util, $id);
  }

  if($id ne "") {
    &step1($cgi, $util, $id);
  }

  if($format ne "plain") {
    print "<br /><br /><br />\n";
    #print $sw->footer();
    print &RfamWWWConfig::footer();
  }
}

#########
# form for entering job ids
#
sub retrieval_form {
  my ($cgi, $util, $id) = @_;
  
  print qq(
<br /><form method="GET" action="$ENV{'SCRIPT_NAME'}">
  <table border="0" align="center" cellpadding="2" cellspacing="0" width="500">
    <tr class="violet2">
      <td><img src="/gfx/blank.gif" width="10" alt="" /></td>
      <td class="normaltext">
        Retrieve result for id: <input type="entry" name="id" value="$id" size="30">
        <input type="submit" value="retrieve">
      </td>
      <td><img src="/gfx/blank.gif" width="10" alt="" /></td>
    </tr>\n);

  if($id eq "") {
    print qq(
    <tr class="violet2">
      <td><img src="/gfx/blank.gif" width="10" alt="" /></td>
      <td>
        <p class="red1">
	  Type your ticket identifier into the box and press
	  <b>retrieve</b>.<br /> The majority of searches are completed within
	  two minutes.
        </p>
      </td>
      <td><img src="/gfx/blank.gif" width="10" alt="" /></td>
    </tr>\n);
  }

  my $format = $cgi->param('format') || "default";
  my @formats = (
		 {'default' => "Marked up"},
		 {'graphic' => "Marked up with graphics"},
		 {'plain'   => "Plain Text"},
		 {'ssaha'   => "SSAHA Summary"},
		);

#  print qq(  <tr class="violet2">
#    <td><img src="/gfx/blank.gif" width="10" alt="" /></td>
#    <td>    Format: <select name="format">\n);
#  for my $form (@formats) {
#    my ($key) = keys %$form;
#    my ($val) = $form->{$key};
#    my $selected = ($format eq $key)?"selected":"";
#    print qq(<option value="$key" $selected>$val</option>);
#  }
#
#  print qq(    </select></td><td><img src="/gfx/blank.gif" width="10" alt="" /></td></tr>\n);

  if($id ne "") {
    print qq(
    <tr><td colspan="3"><img src="/gfx/blank.gif" width="10" alt="" /></td></tr>
    <tr class="violet2">
      <td><img src="/gfx/blank.gif" width="10" alt="" /></td>
      <td>
	<p class="red1">
	  Rfam results are kept on our servers for two weeks
	  following query submission. Results may be retrieved any
	  number of times during this period. After this time queries
	  must be resubmitted if further examination is required.
        </p>
      </td>
      <td><img src="/gfx/blank.gif" width="10" alt="" /></td>
    </tr>\n);
  }

  print qq(
  </table>
</form>
<br clear="all">\n);
}

sub step1 {
  my ($cgi, $util, $id) = @_;

  my $ticket = Website::Blast::Ticket->new({'id' => $id});

  if(!defined $ticket) {
    print qq($id is not a valid identifier.);
    return;
  }

  #########
  # AntiDoS attack section (stops rapid reloading by monkeys)
  # 20 second reload limit
  #
#  my $antidos  = $ticket->basename() . ".antidos";
#  my $timethen = (stat($antidos))[9] || 0;
#  my $timenow  = time();
#  my $limit    = 5;
#  `/bin/touch $antidos`;
#  if($timenow - $timethen < $limit) {
#    #########
#    # Heh. prioritise your job down.
#    #
#    print qq(Please try again in $limit seconds.);
#    return;
#  }

  my @omnitickets = $ticket->omnitickets();

  if(scalar @omnitickets > 0) {
    #########
    # do omni hits
    #
    for my $subid (@omnitickets) {
      #print "HERE <P>";
      my $subticket = Website::Blast::Ticket->new({
						   'id' => $subid,
						  });
      #print "TICKET: $subticket <P>";
      
      my $generic   = Website::Blast::Parser::Generic->new({
							    'util'   => $util,
							    'ticket' => $subticket,
							    'skip_bioperl' => 1, # Don't build bp objs!
							   });
      if(!defined $generic) {
	my $status = $subticket->status() || $STATUS_UNKNOWN;

	if($status == $STATUS_COMPLETED) {
	  print qq(Job $subid failed.<br />\n);

	} elsif($status == $STATUS_RUNNING) {
	  print qq(Job $subid is running.<br />\n);

	} elsif($status == $STATUS_FAILED) {
	  print qq(Job $subid failed.<br />\n);

	} else {
	  print qq(Job $subid is pending execution.<br />\n);
	}
	next;
      }

      print qq(<!-- id:$subid -->\n);

      if($subticket->pfam()) {
	&step2($cgi, $util, $subid, "Website::Blast::Parser::Pfam");
      } else {
	&step2($cgi, $util, $subid, "Website::Blast::Parser::Omniblast", {'skip_bioperl'=>1});
      }
    }

  } else {
    my $generic  = Website::Blast::Parser::Generic->new({
							 'util' => $util,
							 'id'   => $id,
							 'skip_bioperl' => 1, #skip bp objs!
							});

    if(!defined $generic) {
      my $status = $ticket->status() || $STATUS_UNKNOWN;
      
      if($status == $STATUS_COMPLETED) {
	print qq(Job $id failed.<br />\n);
	
      } elsif($status == $STATUS_RUNNING) {
	print qq(Job $id is running.<br />\n);
	
      } elsif($status == $STATUS_FAILED) {
	print qq(Job $id failed.<br />\n);
	
      } else {
	print qq(Job $id is pending execution.<br />\n);
      }
      return;
    }

    my $database = $generic->ticket->database();
    my $name     = "Generic";
    my $format   = $cgi->param('format') || "default";
    my $opts     = {
		    'graphic' => ($format eq "graphic")?"on":"off",
		   };
    
    if($format eq "ssaha") {
      $name = "SSAHA";

    } elsif($format eq "plain") {
      $name = "Plain";

    } else {
      if($database =~ /humpub\/chr/i ||
	 $database =~ /humpub\/finished/ ||
	 $database =~ /humpub\/public_unfinished/ ||
	 $database =~ /humpub\/all/ ||
	 $database =~ /humpub\/public_human/) {
	$name = "Homo_sapiens";
	
      } elsif($database =~ /humpub\/mouse/) {
	$name = "Mus_musculus";
	
      } elsif($database eq "wormpub/allcmid") {
	$name = "C_elegans";
	
      } elsif($database =~ /yeastpub\/NM/i) {
	$name = "N_meningitidis";
	
      } elsif(substr($database, 0, 11) eq "yeastpub/ML") {
	$name = "M_leprae";
	
      } elsif(substr($database, 0, 11) eq "yeastpub/CJ") {
	$name = "C_jejuni";
	
      } elsif(substr($database, 0, 6) eq "merops") {
	$name = "MEROPS";
      }
    }

    my $parsername = "Website::Blast::Parser::$name";
    &step2($cgi, $util, $id, $parsername, $opts);
  }
}


sub step2 {
  my ($cgi, $util, $id, $parsername, $opts) = @_;
  $opts ||= {};

  eval "require $parsername";
  my $parser = $parsername->new({
				 'util'         => $util,
				 'id'           => $id,
				 'cgi'          => $cgi,
				 'graphic'      => $opts->{'graphic'},
				 'skip_bioperl' => $opts->{'skip_bioperl'},
				});
  $parser->parse();
}

