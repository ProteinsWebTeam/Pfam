#!/usr/local/bin/perl -wT
#########
# Author: rmp
# Maintainer: hrh,raw,rmp
# Created: 2003-05-06
# Last Modified: 2003-05-08
#
# Combined and derived from blast_server and omniblast_server
#
# rmp 2002-03-06;  hacking fixes. offline, ticketed system
# hrh 2002-12-09;  multiple sequences
# hrh 2003-04-14;  fixing the filters
# rmp 2004-09-..;  combination of omni & single and move to new blast servers (sans NFS)
#

package blast_combo;
use strict;
use lib qw(
	   /nfs/WWW/SANGER_docs/perl
	   /nfs/WWW/SANGER_docs/bin-offline
	   /nfs/WWW/SANGER_docs/cgi-bin/Rfam
	   /nfs/WWW/SANGER_docs/perl/bioperl-live
	  );

use CGI;
use SangerWeb;
use Website::Blast::Util;
use Website::Blast::Ticket;
#use Website::QueueStub::Blast;



require '/nfs/WWW/SANGER_docs/cgi-bin/Rfam/RfamQueueStub/Blast.pm';
use Website::Utilities::Template;
use RfamWWWConfig;
#use CRC64;
use vars qw($VERSION);
$VERSION = "3.0";

$|=1;
$ENV{'PATH'} = "";

&main();
1;

sub main {
  my $cgi     = CGI->new();
  my $content = "";
  my $util    = Website::Blast::Util->new();
  my $sw      = SangerWeb->new({
				'title'  => "BLAST Server Submission v$VERSION",
				'banner' => "BLAST Server Submission v$VERSION",
			       });
  my $defs    = {
		 'HALT'        => 0,                      # Set to 1 to deactivate blast
		 'multi_limit' => 100,                    # max number of query sequences to be submitted
		 'seq_type'    => "",                     # Either DNA or protein (D/P)
		 'OPTIONS'     => "",                     # Blast options
		 'PROCESSORS'  => 1,                      # No. of processors to use (max=4)
		 'blast_type'  => [],                     # BLAST exe
		 'databases'   => [],                     # Databases to blast against
		 'queries'     => [],                     # (multi) queries to run
		 'omni'        => 0,                      # omni- or not- submission
		 'priority'    => {
				   0  => 'high',
				   10 => 'medium',
				   50 => 'low',
				  },
		};
  
  if($defs->{'HALT'} == 1 || -f "/nfs/WWW/NOLSF" || -f "/nfs/WWW/NOSANGERLSF") {
    #########
    # blast unavailable
    #
    $content .= qq(<P><H3 align = "center">Sorry our BLAST servers are temporarily out of service (please see our home page for details)</H3></P>\n);

  } else {
    #########
    # submit blast
    #
    &get_web_form($cgi, $util, \$content, $defs);	
    
    &check_and_clean_sequence($cgi, $util, \$content, $defs);

    my $errors = &trap_errors($cgi, $util, \$content, $defs);

    unless($errors) {
      &process_options($cgi, $util, \$content, $defs); 

      &bsub($cgi, $util, \$content, $defs);
    }
  }
print $cgi->header();
  print &RfamWWWConfig::header("Sequence search results");
  print $content;

  print &RfamWWWConfig::footer(); #$sw->footer();
}

#########
# get submitted data from the web page
#
sub get_web_form {
  my ($cgi, $util, $content_ref, $defs) = @_;

  if (defined($cgi->param('altoptions'))) {
    my $altoptions = $cgi->param('altoptions') || "";
    $altoptions    =~ s/[\`\'\;$\""\@\{\}\\\[\]~&\*!|]//ig;
    $cgi->param('altoptions', $altoptions);
  }
  
  my $sequence = $cgi->param('sequence');	
  $sequence    =~ s/^\s+//;
  $cgi->param('sequence', $sequence);
  
  #########
  # test sequences
  #
  if (lc($cgi->param('sequence')) eq "llama") {
    $cgi->param('sequence', $util->llama());
    
  } elsif (lc($cgi->param('sequence')) eq "camel") {
    $cgi->param('sequence', $util->camel());
    
  } elsif (lc($cgi->param('sequence')) eq "pelican") {
    $cgi->param('sequence', $util->pelican());
  }
  
  if ($cgi->param('uploadfile') =~/\w/ && $cgi->param('sequence') =~/\w/) {
    $$content_ref .= qq(
<p>
  <B>
    Warning: ambiguous sequence source (both file and text box contain data).<br />
    Assuming you want to use the sequence in the box.
  </B>
</P>\n);

  } elsif ($cgi->param('sequence') eq "" && $cgi->param('uploadfile') ne "") {
    my $uploadfile = $cgi->param('uploadfile');
    $$content_ref .= qq(<p><B>Input sequence taken from uploaded file</B></p>\n);
    
    if($uploadfile) {
      local $/ = undef;
      $uploadfile = <$uploadfile>;
    }
    if($uploadfile =~ /\w+/) {
      $cgi->param('sequence', $uploadfile);
    }
  } 

  #########
  # build database list
  #
  my $dbset     = $cgi->param('dbset') || "some";
  my @databases = ();
  if($dbset eq "all") {
    if(defined $cgi->param('all_dbs')) {
      #########
      # omniblast with all databases submitted from form
      #
      push @databases, map { $_ =~ s/^(.*?)(:.*)?$/$1/; $_; } split(',', $cgi->param('all_dbs'));

    } else {
      #########
      # big_omniblast with all databases from blast_list
      #
      push @databases, $util->all_databases();
    }

  } else {
    if(defined $cgi->param('database')) {
      #########
      # individual blast or omniblast with checked databases
      #
      push @databases, map { $_ =~ s/^(.*?)(:.*)?$/$1/; $_; } $cgi->param('database');

    } else {
      #########
      # big_omniblast with checked database classes from form
      # databases marked '!' in blast-list.txt are already filtered in Util.pm
      #
      for my $f ($util->all_classes()) {
	next unless(defined $cgi->param($f) && $cgi->param($f) eq "yes");
	push @databases, $util->databases_by_class($f);
      }
    }
  }

  if(scalar @databases == 0) {
    $$content_ref .=  "<P><B>You have to select at least one database. Search aborted!</B><P>";
    return 1;
  }

  $defs->{'databases'}  = \@databases;
  $defs->{'blast_type'} = [map { $util->blast_type($_); } $cgi->param('blast_type')];

  if(scalar @{$defs->{'blast_type'}} == 1) {
    #########
    # standard blast
    #
    $defs->{'db_type'} = $util->database_type($databases[0]);

  } else {
    #########
    # omniblast
    #
    $defs->{'omni'} = 1;
  }

  return;
}

#########
# work out the sequence type 
#
sub check_and_clean_sequence {
  my ($cgi, $util, $content_ref, $defs) = @_;
  my $limit       = $defs->{'multi_limit'};
  my $p_seq       = $cgi->param('sequence') || "";
  my @query_array = split (/>(\S+)[ \S]*/ , $p_seq);

  shift @query_array;

  if (scalar @query_array == 0) {
    $query_array[0]  = "UNKNOWN-QUERY";    # assign default name to a single sequence without a header line
    $query_array[1]  = $p_seq;

  } elsif (scalar @query_array > ($limit*2)) {
    $$content_ref .=  "<p><b>only the first $limit sequences will be submitted to the blast server</b></p>";
  }
 
  while(my $name = shift @query_array) {
    my $query   = shift @query_array;
    last unless $query;
    $query    ||= "";
    $query      = uc($query);
    $query      =~ s/\s//g;
    $_          = $query;
    my $A       = tr/A/A/;
    my $C       = tr/C/C/;
    my $G       = tr/G/G/;
    my $T       = tr/T/T/;
    my $total   = $A+$C+$G+$T;

    if ($query eq "") {
      $$content_ref .= "<P><B>Sequence length is zero. Search aborted!</B><P>";
      return;
    }

    if(($total/length($query)) >= 0.7) {
      #########
      # it's DNA
      #
      $query =~ s/[^ACGTUNRYKMBDHVSWNX]//ig;

      if ($defs->{'seq_type'} eq "P") {
        $$content_ref .= "<P><B>You have a mixture of DNA and protein sequences in your fasta file. Search aborted!</B></P>";
        return;

      } else {
	$defs->{'seq_type'} = "D";
      }

    } else {
      #########
      # it's protein
      #
      $query =~ s/[^ARNDCEQGHILKMFPSTWYVXZ]//ig;

      if ($defs->{'seq_type'} eq "D") {
        $$content_ref .= "<P><B>You have a mixture of DNA and protein sequences in your fasta file. Search aborted!</B><P>";
        return;

      } else {
	$defs->{'seq_type'} = "P";
      }      
    }
    
    push @{$defs->{'queries'}}, {
				 'name'  => $name,
				 'query' => $query,
				};
  }

  return
}  

#########
# trap errors
#
sub trap_errors {
  my ($cgi, $util, $content_ref, $defs) = @_;
  my $warning  = undef;
  my $sequence = $cgi->param('sequence') || "";

#  if(scalar @{$defs->{'blast_type'}} == 0) {
#    $warning = qq(No Blast executable specified);
#  }

  if($sequence eq "") {
    $warning = qq(No Sequence given);
  }

  if(!$defs->{'omni'}) {
    my $blast_type = $defs->{'blast_type'}->[0];
    my $seq_type   = $defs->{'seq_type'};
    my $db_type    = $defs->{'db_type'};

    if ($db_type eq "D") {
      if($seq_type eq "P" &&
	 $blast_type ne "wutblastn") {
	$warning = qq(You cannot perform a $blast_type search with a protein sequence against this nucleotide database);

      } elsif($seq_type eq "D" &&
	      $blast_type ne "wublastn" &&
	      $blast_type ne "wutblastx") {
	$warning = qq(You cannot perform a $blast_type search with a nucleotide sequence against this nucleotide database);
      }

    } elsif($db_type eq "P") {
      if($seq_type eq "D" &&
	 $blast_type ne "wublastx") {
	$warning = qq(You cannot perform a $blast_type search with a nucleotide sequence against this protein database);

      } elsif($seq_type eq "P" &&
	      $blast_type ne "wublastp") {
	$warning = qq(You cannot perform a $blast_type search with a protein sequence against this protein database);
      }
    }
  }

  $$content_ref .= qq(<p><b>Error: $warning.</b></p><br /><br /><br />) if(defined $warning);
  
  return $warning;
}

#########
# handle the options
#
sub process_options {
  my ($cgi, $util, $content_ref, $defs) = @_;
  my @options    = ();
  my $altoptions = "";

  if($defs->{'omni'}) {
    #########
    # Omniblast has restricted, simple options
    #
    @options = ("cpus=1", "B=100");

  } else {
    #########
    # Single blast has funkadelic super options
    #
    my $seqlength   = length($cgi->param('sequence'));
    my $align       = $cgi->param('align')        || 100;
    my $expect      = $cgi->param('expect')       || "";
    my $descs       = $cgi->param('descriptions') || "";
    my $hist        = $cgi->param('histogram')    || "";
    my $sort        = $cgi->param('sort')         || "";
    my $stats       = $cgi->param('statistics')   || "";
    my $gencode     = $cgi->param('gencode')      || 1;
    my $blast_type  = $defs->{'blast_type'}->[0];
    @options        = ("cpus=$defs->{'PROCESSORS'}", "-warnings");
    $altoptions     = $cgi->param('altoptions')   || "";
    
    #########
    # Decrease the cut-off if the sequence is very small
    #
    push @options, "S=10" if($seqlength < 30);
    
    #########
    # number of results to display
    #
    push @options, "B=$align";
    
    #########
    # default filtering option
    #
    my $p_filtering = $cgi->param('filtering') || "off";
    my $p_filter    = $cgi->param('filter')    || "off";
    my $filter;
    
    if($p_filtering eq "on") {
      $filter = ($blast_type ne "blastn" && $blast_type ne "wublastn")?"-filter=seg":"-filter=dust";
      
    } elsif ($p_filtering eq "off" && $p_filter ne "off") {
      $filter = "-filter=$p_filter";
    }
    push @options, $filter;
    
    #########
    # change Blast matrix and other Blast options
    #
    unless ($blast_type eq "wublastn" || $blast_type eq "blastn") {
      my $mat = $cgi->param('matrix') || "";
      push @options, "-matrix=$mat" if($mat);
    }
    
    if($descs) {
      push @options, "V=$descs";
      
    } else {
      push @options, "V=$align";  # set to same as alignments  
    }
    
    push @options, "E=$expect"  if($expect);
    push @options, "H=1"        if($hist eq "yes");
    push @options, $sort        unless($sort eq "-sort_by_pvalue");
    push @options, $stats       unless($stats eq "-sump");
    push @options, "C=$gencode" if ($blast_type =~ /blastx/);
  }

  #########
  # store our preferences back into the definitions hash
  #
  $defs->{'OPTIONS'} = join(" ", @options, $altoptions);
}

#########
# 
#
sub bsub {
  my ($cgi, $util, $content_ref, $defs) = @_;
  my $opts        = $defs->{'OPTIONS'};
  $opts           =~ s/\`\"\'\;\|//g;
  ($opts)         = $opts    =~ /(.*)/;
  my $repmask     = $cgi->param('repeatmasker') || "no";
  ($repmask)      = $repmask =~ /(yes|no)/;
  $repmask = "no";
  my $uberid      = $util->get_unique_id();
  my $dest        = $util->hashpath($uberid);
  my @omnitickets = ();
  my $uberticket  = undef;

  for my $query (@{$defs->{'queries'}}) {
    my $sequence = $query->{'query'};
    my $name     = $query->{'name'};
    my $fn       = $dest . ".tmp";
    my $fh;

    eval {
      open ($fh, ">$fn") or die; 
      print $fh ">$name\n$sequence\n";
      close ($fh);
    };
    if($@) {
      $$content_ref .= qq(<H3>Error: Could not create temporary file, try again later</H3>\n);
      return;
    }

    if($defs->{'omni'}) {
      #########
      # Generate jobs for omniblast
      #
      if($defs->{'seq_type'} eq "P") {
	#########
	# If Protein, do a PFAM query
	#
#	my $length = length($cgi->param('sequence'));
#	my $ticket = Website::Blast::Ticket->new({
#						  'id'         => $util->get_unique_id(),
#						  'length'     => $length,
#						  'pfam'       => "1",
#						  'cutoff'     => "0.00001",
#						  '_noload'    => 1,
#						 });
#	my $status = $ticket->save();
#	push @omnitickets, $ticket;		    
      }
      
      for my $database (@{$defs->{'databases'}}) {
	#########
	# create individual tickets
	# work out which executable 
	#
	my $db_type = $util->database_type($database) || "";
	
	if ($defs->{'seq_type'} eq "D") {
	  if ($db_type eq "P") {
	    push @omnitickets, {
				'database'   => $database,
				'blasttype'  => "wublastx",
			       };
	    
	  } else {
	    push @omnitickets, ({
				 'database'   => $database,
				 'blasttype'  => "wublastn",
				},
				{
				 'database'   => $database,
				 'blasttype'  => "wutblastx",
				});
	  }
	  
	} elsif ($defs->{'seq_type'} eq "P") {
	  if ($db_type eq "P") {
	    push @omnitickets, {
				'database'   => $database,
				'blasttype'  => "wublastp",
			       };
	    
	  } else {
	    push @omnitickets, {
				'database'   => $database,
				'blasttype'  => "wutblastn",
			       };
	  }
	}
      }
    } else {
      for my $database (@{$defs->{'databases'}}) {
	push @omnitickets, {
			    'database'   => $database,
			    'blasttype'  => $defs->{'blast_type'}->[0],
			   };
      }
    }
  }
  @omnitickets = ();
#print "Content-type: text/html\n\n";
#print "WOW <P>";
  push @omnitickets, {
		      'blasttype' => 'perl /data/bin/pfam_2004-10-20/rfamseq_blast.pl ',
		      'rfam' => 'yes'
		       };





  my $id_to_run = "";
#  if (scalar @omnitickets > 1) {
    $uberticket = Website::Blast::Ticket->new({
					       'id'          => $uberid,
					       '_noload'     => 1,
					       'remotehost'  => $ENV{'HTTP_X_FORWARDED_FOR'} || "",
					       'referrer'    => $ENV{'HTTP_REFERER'}         || "",
					       'njobs'       => scalar @omnitickets,
					       'repeatmask'  => $repmask,
					       'options'     => $defs->{'OPTIONS'},
					      });

    my $i = 1;
    for my $ot (@omnitickets) {
      $uberticket->$i(sprintf("%s:%s", $ot->{'database'}, $ot->{'blasttype'}));
      #printf STDERR "is_omni = %s\t %s [db type=%s]  %s\t [query type=%s]\n", $defs->{'is_omni'}?"yes":"no", $ot->{'database'}, $util->database_type($ot->{'database'}), $ot->{'blasttype'}, $defs->{'seq_type'};
      $i++;
    }

    $uberticket->save();

#  } elsif(scalar @omnitickets == 1) {
#    $uberticket = $omnitickets[0];

#  } else {
#    $$content_ref .= qq(Error: bad ticket handling. Please contact <a href="/feedback/">webmaster\@sanger.ac.uk</a> and describe the actions which caused this error);
#    return;
    # no jobs
#  }

  $id_to_run = $uberticket->id();
  
  #########
  # create the queuestub which actually submits the job
  #

  my $njobs     = scalar @omnitickets;
  my $priority  = "";
  for my $k (sort { $b <=> $a } keys %{$defs->{'priority'}}) {
    if($njobs > $k) {
      $priority = $defs->{'priority'}->{$k};
      last;
    }
  }
 # print "Content-type: text/html\n\n";
 # print  STDOUT "HERE @omnitickets <P>";
 # foreach (@omnitickets) {
 #   print "DOL: $_ <BR>";
 # }
  my $queuestub = QueueStub::Blast->new({
						  'omnitickets' => \@omnitickets,
						  'blastopts'   => $opts,
						  'repeatmask'  => $repmask,
						  'hashpath'    => $dest,
						  'priority'    => $priority,
#						  'debug'       => 1,
						 });
 # print "QUEUE: $queuestub <P>";
  my $tracker = $queuestub->submit();

  if(!$tracker) {
    $$content_ref .= "Queue submission failed\n";
    
  } else {
    $uberticket->tracker($tracker);
    $uberticket->save();
    
    my $server_name = $ENV{'HTTP_X_FORWARDED_HOST'} || $ENV{'HTTP_X_HOST'};
    my $tmpl        = Website::Utilities::Template->new({
							 'htx' => "$ENV{'DOCUMENT_ROOT'}/../data/blast/templates/getblast.htx",
							});
    $$content_ref .= "<form method=\"GET\" action=\"/cgi-bin/Rfam/getblast\">
  <table border=\"0\" align=\"center\" cellpadding=\"2\" cellspacing=\"0\" width=\"500\">
    <tr class=\"violet2\">
      <td><img src=\"/gfx/blank.gif\" width=\"10\" alt=\"\" /></td>
      <td>
        Retrieve result for id: <input type=\"entry\" name=\"id\" value=\"$id_to_run\" size=\"30\">
        <input type=\"submit\" value=\"retrieve\">
      </td>
      <td><img src=\"/gfx/blank.gif\" width=\"10\" alt=\"\" /></td>
    </tr>
    <tr><td colspan=\"3\"><img src=\"/gfx/blank.gif\" width=\"10\" alt=\"\" /></td></tr>
    <tr class=\"violet2\">
      <td><img src=\"/gfx/blank.gif\" width=\"10\" alt=\"\" /></td>
      <td>
        <p class=\"red1\">
          Your BLAST query has been added to the queue of jobs.<br />The
          majority of BLASTs are completed within two minutes.
        </p>
      </td>
      <td><img src=\"/gfx/blank.gif\" width=\"10\" alt=\"\" /></td>
    </tr>
    <tr><td colspan=\"3\"><img src=\"/gfx/blank.gif\" width=\"10\" alt=\"\" /></td></tr>
    <tr class=\"violet2\">
      <td><img src=\"/gfx/blank.gif\" width=\"10\" alt=\"\" /></td>
      <td>
        <p class=\"red1\">
          To retrieve your results, click the <b>retrieve</b> button
          above, or use the following URL: <a  href=\"http://$server_name/cgi-bin/Rfam/getblast?id=$id_to_run\">http://$server_name/cgi-bin/Rfam/getblast?id=$id_to_run</a>
        </p>
      </td>
      <td><img src=\"/gfx/blank.gif\" width=\"10\" alt=\"\" /></td>
    </tr>
  </table>
</form>";
   # $$content_ref  .= $tmpl->generate({
#				       'status'      => $queuestub->status(),
#				       'id'          => $id_to_run,
#				       'server_name' => $server_name,
#				      });
   # print "CONTENT: $$content_ref <P>";
  }
}

