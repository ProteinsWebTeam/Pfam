package Rfam::RfamSearch;

#
# Modules for dealing with Rfam searches, including blast filters, cmcalibrate wrapper, cmsearch wrapper, ...
#
# ppg

use strict;
use warnings;
use Sys::Hostname;
use File::Copy;
use IO::File;

use RfamUtils;
use Rfam;

use vars qw( @ISA
             @EXPORT );

@ISA    = qw( Exporter );

#getDbSize: fetch the current size of RFAMSEQ
sub getDbSize {
    open(DBSIZE, "< $Rfam::rfamseq_current_dir/DBSIZE") or die "FATAL: failed to open $Rfam::rfamseq_current_dir/DBSIZE\n[$!]";
    my $dbsize=0;
    while(<DBSIZE>){
	if (/(\d+)/){
	    $dbsize=$1;
	    last;
	}
    }
    return $dbsize;
}

#cmBuild:
sub cmBuild {
    my ($cmFile, $seedFile, $version, $name) = @_;
    my $nameCmd = '';
    $nameCmd = " -n $name " if (defined $name && length($name)>0);
    
    #build CM
    unlink $cmFile if -e $cmFile;
    open(CMB, "$Rfam::infernal_path/cmbuild $nameCmd -F $cmFile $seedFile | ") or die "FATAL: failed to open pipe for cmbuild $nameCmd -F  $cmFile $seedFile\n[$!]";
    my $ok=0;
    while(<CMB>){
	if(/INFERNAL $version/){
	    $ok=1;
	}
    }
    close(CMB);
    die "FATAL: what version of Infernal are you running? It is not $version!" if not $ok;
    return 1;
}

#hmmBuild:
sub hmmBuild {
    my ($hmmFile, $seedFile, $version, $name) = @_;
    my $nameCmd = '';
    $nameCmd = " -n $name " if (defined $name && length($name)>0);
    
    my $hmmbuildExe = "$Rfam::hmmer2_path/hmmbuild";
    $hmmbuildExe = "$Rfam::hmmer3_path/hmmbuild" if $version =~ /^3/;
    #build HMM
    unlink $hmmFile if -e $hmmFile;
    open(HMMB, "$hmmbuildExe $nameCmd $hmmFile $seedFile | ") or die "FATAL: failed to open pipe for hmmbuild $nameCmd -F  $hmmFile $seedFile\n[$!]";
    my $ok=0;
    while(<HMMB>){
#HMMER 2.3.2 (Oct 2003)
## HMMER 3.0a2 (March 2009); http://hmmer.org/
	if(/HMMER $version/){
	    $ok=1;
	}
    }
    close(HMMB);
    die "FATAL: what version of HMMER are you running? It is not $version!" if not $ok;
    return 1;
}


#cmCalibrate: takes a CM file and runs cmcalibrate on the Sanger farm using MPI

#Systems MPI help documentation:
#http://scratchy.internal.sanger.ac.uk/wiki/index.php/How_to_run_MPI_jobs_on_the_farm

#For MPI to work, you need to make sure Infernal has been compiled correctly.
#On the farm and in the Infernal directory:
#ssh farm-login ; cd ~/inst/infernal-1.0
#make distclean; ./configure --enable-mpi --prefix='/software/rfam/share/infernal-1.0'  ; make ; make install
#setenv PATH /software/rfam/share/infernal-1.0/bin/:${PATH}

#####BEYOND TESTING:
#make distclean; ./configure --enable-mpi --prefix='/software/rfam/'  ; make ; make install

#ssh keys need to be correct. Remove all ^"bc-*" entries from your ~/.ssh/known_hosts file.
#Optionally add "StrictHostKeyChecking no" to your ~/.ssh/config

#TO ADD: 
#FIX THE FILE NAMES & LOCATIONS CLUDGE!

sub cmCalibrate {
    my $cm = shift; #Handed a CM file generated by cmbuild
    my $lustre = shift;#Farm dir
    my $pwd = shift;   #Work dir
    my $debug = shift;
    
    $cm = "CM" if not defined $cm; #This only works if working from a home directory... 
    die "cmfile \42$cm\42 either does not exist or is empty!" if !(-s $cm);
    
    my $preferedRunTime = 5*60;
    my $maxCpus = 60;
    my $cpus;
    #Use cmcalibrate --forecast to allocate the number of cpus to use:
    #print "cmcalibrate --forecast'ing....\n";
    $cpus = 1;
    my $estimatedCpuTime=10000;
    open(FC, "$Rfam::infernal_path/cmcalibrate --forecast $cpus $pwd/$cm | ") or die "FATAL: failed to open pipe cmcalibrate --forecast $cpus $pwd/$cm \n[$!]";
    while(<FC>){
	if(/#\s+all.+\s+(\d+):(\d+):(\d+)/){
	    $estimatedCpuTime = (60*60)*$1 + 60*$2 + $3;
	    print "cmcalibrate MPI:\n\tEstimated CPU time:  [$1:$2:$3] ($estimatedCpuTime secs)\n";
	    last;
	}
    }
    close(FC);
    #Want a runtime less than $preferedRunTime minutes: 
    $cpus = int($estimatedCpuTime/$preferedRunTime);
    $cpus = $maxCpus if $cpus>$maxCpus;
    $cpus = 2        if $cpus<2;
    
    my $estimatedWallTime=$preferedRunTime;
    open(FC, "$Rfam::infernal_path/cmcalibrate --forecast $cpus $pwd/$cm | ") or die "FATAL: failed to open pipe cmcalibrate --forecast $cpus $pwd/$cm \n[$!]";
    while(<FC>){
	if(/#\s+all.+\s+(\d+):(\d+):(\d+)/){
	    $estimatedWallTime=(60*60)*$1 + 60*$2 + $3;
	    print "\tEstimated WALL time: [$1:$2:$3] ($estimatedWallTime secs) on $cpus CPUs\n";
	    last;
	}
    }
    close(FC);
        
    #Generate a MPI script:
    my $mpiScript = "#!/bin/bash
# An OPENMPI LSF script for running cmcalibrate
# Submit this script via bsub to use.
 
# Parse the LSF hostlist into a format openmpi understands and find the number of CPUs we are running on.
echo \$LSB_MCPU_HOSTS | awk '{for(i=1;i <=NF;i=i+2) print \$i \" slots=\" \$(i+1); }' >> /tmp/hostfile.\$LSB_JOBID
CPUS=`echo \$LSB_MCPU_HOSTS | awk '{for(i=2;i <=NF;i=i+2) { tot+=\$i; } print tot }'` 

# Now run our executable 
mpirun  --mca mpi_paffinity_alone 1 --hostfile /tmp/hostfile.\$LSB_JOBID --np \$CPUS $Rfam::infernal_path/cmcalibrate --mpi -s 1 $lustre/$cm
";

    my $mpiScriptFile = $lustre . '/' . $cm . '.' . $$ . '_mpi_script.sh';#be cleverer here
    open(MS, "> $mpiScriptFile") or die "FATAL: failed to open file: $mpiScriptFile\n[$!]";
    print MS $mpiScript;
    close(MS);

    chmod 0775,  $mpiScriptFile or die "FATAL: failed to run [chmod 0775,  $mpiScriptFile]\n[$!]";
    
    my $mpiScriptOut =  $cm . '.' . $$ . '_mpi_script.out';
    my $bjobName = "cmcal" . $$ . hostname;
    my $bsubOpts = "-o $lustre/$mpiScriptOut -q long  -J\"$bjobName\" -n$cpus -R\'select[model==HS21_E5450_8]\'";
    print "Running: bsub $bsubOpts $mpiScriptFile\n";
    system("bsub $bsubOpts $mpiScriptFile > $pwd/$mpiScriptOut\.std") and die "FATAL: failed to run to run: bsub $bsubOpts $mpiScriptFile\n[$!]";
    $debug = 'cmcalibrate' if defined $debug;
    RfamUtils::wait_for_farm($bjobName, 'cmcalibrate', $cpus, 3*$estimatedWallTime+120, $debug ); #wait an extra few mins then the job will be killed, assuming MPI+Farm badness.
    
    copy( "$lustre/$cm", "$pwd/$cm" ) or die "FATAL: failed to copy $lustre/$cm to $pwd/$cm\n[$!]";
    copy("$lustre/$mpiScriptOut", "$pwd/$mpiScriptOut") or die "FATAL: failed to copy $lustre/$mpiScriptOut to $pwd/$mpiScriptOut\n[$!]";

    open(MPIOUT, "< $pwd/$mpiScriptOut") or die "FATAL: failed to open $pwd/$mpiScriptOut for reading\n[$!]";
    
    my $calibrateTime=0;
    while(<MPIOUT>){
	if(/\#\s+CPU\s+time\:\s+(\S+)u\s+(\S+)s/){
	    $calibrateTime=$1+$2;
	    last;
	}
    }
    close(MPIOUT);
    
    return $calibrateTime;
}

#Returns true if the CM file has been calibrated:
sub isCmCalibrated {
    my $cm = shift; #Handed a CM file generated by cmbuild and hopefully cmcalibrate'd
    $cm = 'CM' if not defined $cm;
    return 0 if not -s $cm;

    open(CM, "< $cm") or die "FATAL: failed to open the file $cm for a calibration check\n[$!]";
    my $ok=0;
    while(<CM>){
	if (/^CCOM.+cmcalibrate/){
	   $ok=1;
	   last;
	}
    }
    return $ok;
    
    #Alternative check:
    #open(CMS, "$Rfam::infernal_path/cmstat -m $pwd/CM |") or die "FATAL: failed to open a pipe for $Rfam::infernal_path/cmstat -m $pwd/CM\n[$!]";
    #my $cms = join('',<CMS>);
    #close(CMS);
    #$buildCm = 1 if $cms =~ /No\s+E-value\s+exp\s+tail\s+statistics/ || $cms =~ /No\s+filter\s+threshold\s+statistics/;


}

=head1 AUTHOR

Paul Gardner, C<pg5@sanger.ac.uk>

=head1 COPYRIGHT

Copyright (c) 2009: Genome Research Ltd.

Authors: Paul Gardner (pg5@sanger.ac.uk)

This is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
details.

You should have received a copy of the GNU General Public License along with
this program. If not, see <http://www.gnu.org/licenses/>.

=cut

1;


