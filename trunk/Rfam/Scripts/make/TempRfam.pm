package Rfamnew; 

#Occasionally useful Rfam utilities

use strict;
use warnings;
use Sys::Hostname;
use File::stat;
use RfamUtils; 
#use Rfam::RfamSearch;
use Cwd;
use Data::Dumper;
use Mail::Mailer;
use File::Copy;
use vars qw( @ISA
             @EXPORT
);

@ISA    = qw( Exporter );

sub slurpDesc {
    
    my $descFile=shift;
    $descFile='DESC' if not defined $descFile;
    my %desc;
    
    my @tags = qw(
    **
AC
AU
BM
CC
DE
DR
GA
ID
NC
PI
RN
SE
SS
TC
TP
WK);
    
    my @litTags = qw(
RA
RL
RM
RT
);
    foreach my $t (@tags){
	$desc{$t}='';
    }
    
    my %litTags;
    foreach my $t (@litTags){
	$litTags{$t}='';
    }
 
	open(DE, "< $descFile") or die "FATAL: failed to open $descFile file!\n[$!]";
    	my ($refNo, @refs);
    	while(<DE>){
		chomp;
		if(/^RN\s+\[(\d+)\]/){
		   	 $refNo=int($1)-1 if defined $1 && $1>0 && length($1)>0;
		}
		elsif(/^(R\S)\s+(.+)/ && defined $refNo){
	    	next if length($refNo) == 0 or length($1) == 0 or length($2) == 0;
	    	if (not defined $refs[$refNo]{$1}){
			$refs[$refNo]{$1} = $2;
	    	}
	    else {
		$refs[$refNo]{$1} .= "\n$1   " . $2;
	    }
	}
	elsif(/^(R\S)\s+(.+)/ && not defined $refNo){
	    print STDERR "WARNING: your references are munged, you need an RN line first!\n";
	}
	elsif(/^(\S{2})\s+(.+)/){#elsif(/^(\S{2})\s+(.+)\s+/ || /^(\S{2})\s+(.+)/){
	    if (defined $desc{$1} && length($desc{$1}) == 0){
		$desc{$1}.=$2;
	    }
	    elsif(defined $desc{$1}){
		$desc{$1}.="\n$1   " . $2;
	    }
	    print STDERR "WARNING: Strange Desc File line, [$1] is an undefined tag: [$_]\n" if not defined $desc{$1};
	}
    }
    print STDERR "WARNING: your DESC file contains no references!\n" if not defined $refNo;
    print STDERR "WARNING: your DESC file is missing SO DR lines!\n" if ($desc{'DR'} !~ /SO/);
    print STDERR "WARNING: your DESC file is missing GO DR lines!\n" if ($desc{'DR'} !~ /GO/);
    print STDERR "WARNING: your DESC file is missing a WK entry!\n\tFORMAT is \47DR   http://en.wikipedia.org/wiki/RNA\47\n" if  $desc{'WK'} !~ /http:\/\/en.wikipedia.org\/wiki\/(\S+)/;
    
    
    $desc{'RN'}=\@refs if defined $refNo;
    return \%desc;
}

#Returns true if the CM file has been calibrated:
sub isCmCalibrated {
    my $cm = shift; #Handed a CM file generated by cmbuild and hopefully cmcalibrate'd
    $cm = 'CM' if not defined $cm;
    return 0 if not -s $cm;

    open(CM, "< $cm") or die "FATAL: failed to open the file $cm for a calibration check\n[$!]";
    my $ok=0;
    while(<CM>){
	if (/^ECMLC/){
	#if (/^CCOM.+cmcalibrate/){
	   $ok=1;
	   last;
	}
    }
    return $ok;
    

}

#getDbSize: fetch the current size of RFAMSEQ
##replace this once dbsize env variable set!!!!
sub getDbSize {
#    open(DBSIZE, "< $Rfam::rfamseq_current_dir/DBSIZE") or die "FATAL: failed to open $Rfam::rfamseq_current_dir/DBSIZE\n[$!]";
 #   my $dbsize=0;
	my $dbsize=50000;
 #   while(<DBSIZE>){
#	if (/(\d+)/){
#	    $dbsize=$1;
#	    last;
#	}
 #   }
    return $dbsize;
}

#cmBuild:
sub cmBuild {
    my ($cmFile, $seedFile, $version, $name) = @_;
    my $nameCmd = '';
    $nameCmd = " -n $name " if (defined $name && length($name)>0);
    
    #build CM
    unlink $cmFile if -e $cmFile;
    open(CMB, "$infernal_path/cmbuild $nameCmd -F $cmFile $seedFile | ") or die "FATAL: failed to open pipe for cmbuild $nameCmd -F  $cmFile $seedFile\n[$!]";
    my $ok=0;
    while(<CMB>){
	if(/INFERNAL $version/){
	    $ok=1;
	}
    }
    close(CMB);
    die "FATAL: what version of Infernal are you running? It is not $version!" if not $ok;
    return 1;
}

#cmCalibrate: takes a CM file and runs cmcalibrate on the Sanger farm using MPI

#Systems MPI help documentation:
#http://scratchy.internal.sanger.ac.uk/wiki/index.php/How_to_run_MPI_jobs_on_the_farm


sub cmCalibrate {
    my $cm = shift; #Handed a CM file generated by cmbuild
    my $lustre = shift;#Farm dir
    my $pwd = shift;   #Work dir
    my $debug = shift;
    my $bigmem = shift;
    my $cpus; 
    $cm = "CM" if not defined $cm; #This only works if working from a home directory... 
    die "cmfile \42$cm\42 either does not exist or is empty!" if !(-s $cm);
    
    #Want a runtime less than $preferedRunTime minutes: 
    #$cpus = $maxCpus if $cpus>$maxCpus;
    $cpus = 2        if $cpus<2;
    
        
    #Generate a MPI script:
    my $mpiScript = "#!/bin/bash
# An OPENMPI LSF script for running cmcalibrate
# Submit this script via bsub to use.
 
# Parse the LSF hostlist into a format openmpi understands and find the number of CPUs we are running on.

# Now run our executable 
$infernal_path/cmcalibrate $lustre/$cm
";

    my $mpiScriptFile = $lustre . '/' . $cm . '.' . $$ . '_mpi_script.sh';#be cleverer here
    open(MS, "> $mpiScriptFile") or die "FATAL: failed to open file: $mpiScriptFile\n[$!]";
    print MS $mpiScript;
    close(MS);

    chmod 0775,  $mpiScriptFile or die "FATAL: failed to run [chmod 0775,  $mpiScriptFile]\n[$!]";
    
    my $mpiScriptOut =  $cm . '.' . $$ . '_mpi_script.out';
    my $bjobName = "cmcal" . $$;
    my $bsubOpts;
    if (defined $bigmem) {
	    	$bsubOpts = "-o $lustre/$mpiScriptOut -R \"span[ptile=4]\" -q production-rh6 -a mpi -M3500000 -R\"select[mem>3500] rusage[mem=3500]\"  -J\"$bjobName\" -n$cpus -R\'select[model==BL460C_G6]\'";
	} else {
		#$bsubOpts = "-o $lustre/$mpiScriptOut -q long  -J\"$bjobName\" -n$cpus -R\'select[model==HS21_E5450_8]\' -R \'select[mem>1000] rusage[mem=1000]\' -M 1000000";
		$bsubOpts = "-o $lustre/$mpiScriptOut -q production-rh6  -J\"$bjobName\" -n$cpus -R \'select[mem>1500] rusage[mem=1500]\' -M 1500000";
		} 
	print "Running: bsub $bsubOpts $mpiScriptFile\n";
    system("bsub $bsubOpts $mpiScriptFile > $pwd/$mpiScriptOut\.std") and die "FATAL: failed to run to run: bsub $bsubOpts $mpiScriptFile\n[$!]";
    $debug = 'cmcalibrate' if defined $debug;
    wait_for_farm($bjobName, 'cmcalibrate', $cpus ); #wait an extra few mins then the job will be killed, assuming MPI+Farm badness.
    
    copy( "$lustre/$cm", "$pwd/$cm" ) or die "FATAL: failed to copy $lustre/$cm to $pwd/$cm\n[$!]";
    copy("$lustre/$mpiScriptOut", "$pwd/$mpiScriptOut") or die "FATAL: failed to copy $lustre/$mpiScriptOut to $pwd/$mpiScriptOut\n[$!]";

    open(MPIOUT, "< $pwd/$mpiScriptOut") or die "FATAL: failed to open $pwd/$mpiScriptOut for reading\n[$!]";
    
    my $calibrateTime=0;
    while(<MPIOUT>){
	if(/\#\s+CPU\s+time\:\s+(\S+)u\s+(\S+)s/){
	    $calibrateTime=$1+$2;
	    last;
	}
    }
    close(MPIOUT);
    
    return $calibrateTime;
}

sub wait_for_farm {
    
    my ($bjobname, $jobtype, $nobjobs, $toKill, $debug) = @_;
    
    my $wait = 1;
    my $bjobcount = 1;
    my $bjobinterval = 15;
    my $jobs = $nobjobs;
    my $startTime = time();
    my $nowTime=0;
    my $firstRun;
    while($wait){
	
	sleep($bjobinterval); 
	
	$jobs = 0;
	my ($bjpend, $bjrun)  = (0, 0);
	open(S, "bjobs -J $bjobname |") or die "FATAL: failed to open pipe \'bjobs -J $bjobname |\'\n[$!]";
	while(<S>) {
	    $bjpend++ if (/PEND/);
	    $bjrun++ if (/RUN/);
	    if (/RUN/ && not defined $firstRun){
		$firstRun = time();
	    }
	}
	close(S);
	$jobs = $bjpend + $bjrun;
	
	$jobs = $nobjobs if $jobtype eq 'cmcalibrate' && $bjrun == 1;
	
	if ($jobs < int($nobjobs*(1-0.95)) ){#Once 95% of jobs are finished, check frequently.
	    $bjobinterval=15;
	}      
	elsif ($jobs < int($nobjobs*(1-0.90)) ){#Once 90% of jobs are finished, check a little more frequently.
	    $bjobinterval=15 + int(log($bjobcount/2)); 
	}
	else {#otherwise check less & less frequently (max. interval is ~300 secs = 5 mins).
	    if ($bjobinterval<300){ $bjobinterval = $bjobinterval + int(log($bjobcount));}
	}
	
	if($jobs){
	    $nowTime = time();
	    my @humanTime = gmtime($nowTime-$startTime);
	    printf STDERR "There are $jobs $jobtype jobs of $nobjobs still running after $bjobcount checks (PEND:$bjpend,RUN:$bjrun). Check interval:$bjobinterval secs [TotalTime=%dD:%dH:%dM:%dS].\n", @humanTime[7,2,1,0]; 
	    if(defined $toKill && defined $firstRun && ($nowTime-$firstRun)>$toKill){
		printf STDERR "WARNING: this job is taking too long therefore I am backing out. Hopefully it'll restart nicely.\n";
		#########
		#DEBUG -- MOSTLY TO TRACK DOWN MPI PROBLEMS:
		#MAKES A FILE FOR EACH MPIRUN NODE CONTAINING STRACE INFO AND PS.
		if (defined $debug){
		    printf STDERR "DEBUG start!\n";
		    
		    my $user =  'pg5';
		    $user =  getlogin() if defined getlogin();
		    my $pwd = getcwd;
		    print "DEBUG: pwd=$pwd, user=$user\n";
		    open(S, "bjobs -J $bjobname |") or die "FATAL: failed to open pipe \'bjobs -J $bjobname |\'\n[$!]";
		    while(<S>) {
			if(/(\d+)\*(bc-\S+)/){
			    my $node = $2;
			    print "node: $node\n";
			    open(B, "ssh $node ps -U $user -o pid,user,\%cpu,\%mem,cmd --sort cmd |") or warn "FATAL: failed to open pipe [ssh $node ps -U $user -o pid,user,\%cpu,\%mem,cmd --sort cmd]\n[$!]";
			    while(my $b=<B>) {
				print $b;
				if($b=~/(\d+)\s+\S+\s+(\S+)\s+(\S+).+$debug/){
				    # 6456 pg5      99.7  0.1 /software/rfam/share/infernal-1.0/bin/cmcalibrate --mpi -s 1 CM
				    my $debugFile="\$HOME/$$\.mpi.debug.$debug.$1.$node";
				    print("ssh $node \'strace -p $1 -o $debugFile\'");
				}
			    }	    
			    close(B);
			}
		    }
		    close(S);
		}
		printf STDERR "DEBUG end!\n";
		#DEBUG ENDS
		########
		system("bkill -J $bjobname ") and die "FATAL: failed to run [bkill -J $bjobname]\n[$!]";
	    }
	}else{
	    $wait = 0;
	}
	$bjobcount++;
    }
    
    return 1;
    
}



######################################################################

=head1 AUTHOR

Sarah Burge, swb@ebi.ac.uk

=head1 COPYRIGHT

Copyright (c) 2013: European Bioinformatics Institute

Authors: Sarah Burge swb@ebi.ac.uk

This is based on code taken from the Rfam modules at the Sanger institute.

This is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
details.

You should have received a copy of the GNU General Public License along with
this program. If not, see <http://www.gnu.org/licenses/>.

=cut

1;



